<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>structural-typing.assist.special-words documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Structural-typing 2.0.3 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>structural-typing</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>assist</span></div></div></li><li class="depth-3 branch"><a href="structural-typing.assist.defaults.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>defaults</span></div></a></li><li class="depth-3 branch"><a href="structural-typing.assist.lifting.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>lifting</span></div></a></li><li class="depth-3 branch"><a href="structural-typing.assist.oopsie.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>oopsie</span></div></a></li><li class="depth-3 branch"><a href="structural-typing.assist.predicate-defining.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>predicate-defining</span></div></a></li><li class="depth-3 branch current"><a href="structural-typing.assist.special-words.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>special-words</span></div></a></li><li class="depth-3 branch"><a href="structural-typing.assist.testutil.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>testutil</span></div></a></li><li class="depth-3"><a href="structural-typing.assist.type-repo.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>type-repo</span></div></a></li><li class="depth-2 branch"><a href="structural-typing.doc.html"><div class="inner"><span class="tree" style="top: -238px;"><span class="top" style="height: 247px;"></span><span class="bottom"></span></span><span>doc</span></div></a></li><li class="depth-2 branch"><a href="structural-typing.global-type.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>global-type</span></div></a></li><li class="depth-2 branch"><a href="structural-typing.preds.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>preds</span></div></a></li><li class="depth-2"><a href="structural-typing.type.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>type</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="structural-typing.assist.special-words.html#var-ALL"><div class="inner"><span>ALL</span></div></a></li><li class="depth-1"><a href="structural-typing.assist.special-words.html#var-each-of"><div class="inner"><span>each-of</span></div></a></li><li class="depth-1"><a href="structural-typing.assist.special-words.html#var-explain-with"><div class="inner"><span>explain-with</span></div></a></li><li class="depth-1"><a href="structural-typing.assist.special-words.html#var-includes"><div class="inner"><span>includes</span></div></a></li><li class="depth-1"><a href="structural-typing.assist.special-words.html#var-not-nil"><div class="inner"><span>not-nil</span></div></a></li><li class="depth-1"><a href="structural-typing.assist.special-words.html#var-paths-of"><div class="inner"><span>paths-of</span></div></a></li><li class="depth-1"><a href="structural-typing.assist.special-words.html#var-RANGE"><div class="inner"><span>RANGE</span></div></a></li><li class="depth-1"><a href="structural-typing.assist.special-words.html#var-reject-missing"><div class="inner"><span>reject-missing</span></div></a></li><li class="depth-1"><a href="structural-typing.assist.special-words.html#var-reject-nil"><div class="inner"><span>reject-nil</span></div></a></li><li class="depth-1"><a href="structural-typing.assist.special-words.html#var-required-path"><div class="inner"><span>required-path</span></div></a></li><li class="depth-1"><a href="structural-typing.assist.special-words.html#var-requires"><div class="inner"><span>requires</span></div></a></li><li class="depth-1"><a href="structural-typing.assist.special-words.html#var-requires-mentioned-paths"><div class="inner"><span>requires-mentioned-paths</span></div></a></li><li class="depth-1"><a href="structural-typing.assist.special-words.html#var-show-as"><div class="inner"><span>show-as</span></div></a></li><li class="depth-1"><a href="structural-typing.assist.special-words.html#var-through-each"><div class="inner"><span>through-each</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">structural-typing.assist.special-words</h2><div class="doc"><div class="markdown"><p>There are a number of symbols that have special meanings. They are aggregated here for convenience.</p></div></div><div class="public anchor" id="var-ALL"><h3>ALL</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>When included in a path, expects a collection and applies the rest of the path to each element.</p></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/guts/compile/compile_path.clj#L168">view source</a></div></div><div class="public anchor" id="var-each-of"><h3>each-of</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Use <code>each-of</code> to describe a &ldquo;forking&rdquo; path. This is convenient when two parts of a bigger data structure should be built the same way.</p>
<pre><code>(type! :Plat {[:corners (each-of :nw :ne :sw :se)] (includes :GeoPoint)})
</code></pre><p><a href="structural-typing.assist.special-words.html#var-through-each">through-each</a> is a synonym. I tend to use <code>each-of</code> for the end of the path, <code>through-each</code> for a fork earlier than that.</p></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/guts/type_descriptions/flatten.clj#L49">view source</a></div></div><div class="public anchor" id="var-explain-with"><h3>explain-with</h3><div class="usage"><code>(explain-with explainer predicate)</code></div><div class="doc"><div class="markdown"><p>After the <code>predicate</code> fails, the failure will need to be explained. Arrange for <code>explainer</code> to be called with the <a href="structural-typing.assist.oopsie.html#var-oopsie">oopsie</a> that results from the failure.</p>
<pre><code> (explain-with #(format &quot;Yo! %s has %s characters, which is WAY too long.&quot;
                        (:leaf-value %)
                        (count (:leaf-value %)))
               #(&lt; (count %) 8)))
</code></pre></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/guts/preds/annotating.clj#L19">view source</a></div></div><div class="public anchor" id="var-includes"><h3>includes</h3><div class="usage"><code>(includes type-signifier)</code></div><div class="doc"><div class="markdown"><p>During creation of a type by <a href="structural-typing.type.html#var-named">named</a> or <a href="structural-typing.global-type.html#var-type.21">type!</a>, a call to <code>includes</code> is replaced with the type the <code>type-signifier</code> refers to.</p></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/guts/type_descriptions/type_expander.clj#L28">view source</a></div></div><div class="public anchor" id="var-not-nil"><h3>not-nil</h3><div class="usage"><code>(not-nil &amp; args)</code></div><div class="doc"><div class="markdown"><p>WARNING: #&rsquo;structural-typing.guts.preds.pseudopreds/not-nil is deprecated. Deprecated in favor of <code>required-path</code>, <code>reject-nil</code>, or <code>reject-missing</code>.</p></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/guts/preds/pseudopreds.clj#L103">view source</a></div></div><div class="public anchor" id="var-paths-of"><h3>paths-of</h3><div class="usage"><code>(paths-of type-signifier-or-map)</code></div><div class="doc"><div class="markdown"><p>Include all the paths of a type (or a literal map) within a path.</p>
<pre><code> (type! :StrictX (includes :X)
                 (requires (paths-of :X)))
</code></pre><p>The above example constructs a stricter version of <code>:X</code> by insisting all of its paths are required.</p><p>When the argument is a map, it is flattened before the paths are extracted, so that <code>{:a {:b even?}}</code> and <code>{[:a :b] even?}</code> have the same effect. (Included types are already flat.)</p></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/guts/type_descriptions/flatten.clj#L59">view source</a></div></div><div class="public anchor" id="var-RANGE"><h3>RANGE</h3><div class="usage"><code>(RANGE inclusive-start exclusive-end)</code></div><div class="doc"><div class="markdown"><p>Use this in a path to select a range of values in a collection. The first argument is inclusive; the second exclusive.</p>
<pre><code>(type! :ELEMENTS-1-AND-2-ARE-EVEN {[(RANGE 1 3)] even?})
</code></pre></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/guts/compile/compile_path.clj#L257">view source</a></div></div><div class="public anchor" id="var-reject-missing"><h3>reject-missing</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>This appears in a predicate list, but it is never called directly. Its appearance means that cases like the following are rejected:</p>
<pre><code>user=&gt; (type! :X {:a [string? reject-missing]})
user=&gt; (built-like :X {})
:a does not exist

user=&gt;  (type! :X {[(RANGE 0 3)] [reject-missing even?]})
user=&gt; (built-like :X [])
[0] does not exist
[1] does not exist
[2] does not exist
</code></pre><p>See also <a href="structural-typing.assist.special-words.html#var-reject-nil">reject-nil</a> and <a href="structural-typing.assist.special-words.html#var-required-path">required-path</a>.</p></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/guts/preds/pseudopreds.clj#L54">view source</a></div></div><div class="public anchor" id="var-reject-nil"><h3>reject-nil</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>False iff the value given is <code>nil</code>. By default, type descriptions allow nil values, following Clojure&rsquo;s lead. To reject nils, use type descriptions like this:</p>
<pre><code>(type! :X {:a [reject-nil string?]})
</code></pre><p>&hellip; or, when checking types directly:</p>
<pre><code>(built-like [string? reject-nil] nil)
</code></pre><p>See also <a href="structural-typing.assist.special-words.html#var-reject-missing">reject-missing</a> and <a href="structural-typing.assist.special-words.html#var-required-path">required-path</a>.</p></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/guts/preds/pseudopreds.clj#L24">view source</a></div></div><div class="public anchor" id="var-required-path"><h3>required-path</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>False iff a key/path does not exist or has value <code>nil</code>. See also <a href="structural-typing.assist.special-words.html#var-reject-missing">reject-missing</a> and <a href="structural-typing.assist.special-words.html#var-reject-nil">reject-nil</a>.</p></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/guts/preds/pseudopreds.clj#L42">view source</a></div></div><div class="public anchor" id="var-requires"><h3>requires</h3><div class="usage"><code>(requires &amp; args)</code></div><div class="doc"><div class="markdown"><p>Often, all you want to say about some parts of a type is that they&rsquo;re required. <code>requires</code> is a shorthand way to do that.</p>
<pre><code>(type! :Point (requires :x :y))
(type! :Line (requires [:start :x] [:start :y]))
(type! :Line (requires [(through-each :start :end) (:each-of :x :y)]))
</code></pre></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/guts/type_descriptions/ppps.clj#L14">view source</a></div></div><div class="public anchor" id="var-requires-mentioned-paths"><h3>requires-mentioned-paths</h3><div class="usage"><code>(requires-mentioned-paths &amp; condensed-type-descriptions)</code></div><div class="doc"><div class="markdown"><p>Canonicalizes the type descriptions into a single path-&gt;pred map and adds <a href="structural-typing.assist.special-words.html#var-required-path">required-path</a> to each path&rsquo;s predicates.</p>
<pre><code> (type! :X (requires-mentioned-paths (includes :Point)
                                     {:color rgb-string?}))
</code></pre><p>Note: It can&rsquo;t require paths you don&rsquo;t mention. The easiest way to mention a path is to name it in a <code>requires</code> - which may be either an argument to this function or outside it:</p>
<pre><code> (type! :X (requires-mentioned-paths (requires :name)
                                     (includes :Point)))
 (type! :X (requires :name)
           (requires-mentioned-paths (includes :Point)))
</code></pre></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/guts/type_descriptions.clj#L22">view source</a></div></div><div class="public anchor" id="var-show-as"><h3>show-as</h3><div class="usage"><code>(show-as name predicate)</code></div><div class="doc"><div class="markdown"><p>Associate the given <code>name</code> string with the predicate for use when predicate failures are explained.</p>
<pre><code>  (show-as &quot;less than 3&quot; (partial &gt;= 3))
</code></pre></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/guts/preds/annotating.clj#L6">view source</a></div></div><div class="public anchor" id="var-through-each"><h3>through-each</h3><div class="usage"><code>(through-each &amp; alternatives)</code></div><div class="doc"><div class="markdown"><p>Use <code>through-each</code> to describe a &ldquo;forking&rdquo; path. This is convenient when two parts of a bigger data structure should be built the same way.</p>
<pre><code>(type! :Line {[(through-each :start :end) :location] (includes :Point)})
</code></pre><p><a href="structural-typing.assist.special-words.html#var-each-of">each-of</a> is a synonym. I tend to use <code>each-of</code> for the end of the path, <code>through-each</code> for a fork earlier than that.</p></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/guts/type_descriptions/flatten.clj#L39">view source</a></div></div></div></body></html>