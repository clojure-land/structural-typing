<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>structural-typing.preds documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Structural-typing 2.0.5 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>structural-typing</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>assist</span></div></div></li><li class="depth-3 branch"><a href="structural-typing.assist.defaults.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>defaults</span></div></a></li><li class="depth-3 branch"><a href="structural-typing.assist.lifting.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>lifting</span></div></a></li><li class="depth-3 branch"><a href="structural-typing.assist.oopsie.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>oopsie</span></div></a></li><li class="depth-3 branch"><a href="structural-typing.assist.predicate-defining.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>predicate-defining</span></div></a></li><li class="depth-3 branch"><a href="structural-typing.assist.special-words.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>special-words</span></div></a></li><li class="depth-3 branch"><a href="structural-typing.assist.testutil.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>testutil</span></div></a></li><li class="depth-3"><a href="structural-typing.assist.type-repo.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>type-repo</span></div></a></li><li class="depth-2 branch"><a href="structural-typing.doc.html"><div class="inner"><span class="tree" style="top: -238px;"><span class="top" style="height: 247px;"></span><span class="bottom"></span></span><span>doc</span></div></a></li><li class="depth-2 branch"><a href="structural-typing.global-type.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>global-type</span></div></a></li><li class="depth-2 branch current"><a href="structural-typing.preds.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>preds</span></div></a></li><li class="depth-2"><a href="structural-typing.type.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>type</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="structural-typing.preds.html#var-all-of"><div class="inner"><span>all-of</span></div></a></li><li class="depth-1"><a href="structural-typing.preds.html#var-at-most-keys"><div class="inner"><span>at-most-keys</span></div></a></li><li class="depth-1"><a href="structural-typing.preds.html#var-exactly"><div class="inner"><span>exactly</span></div></a></li><li class="depth-1"><a href="structural-typing.preds.html#var-exactly-keys"><div class="inner"><span>exactly-keys</span></div></a></li><li class="depth-1"><a href="structural-typing.preds.html#var-exactly.3D.3D"><div class="inner"><span>exactly==</span></div></a></li><li class="depth-1"><a href="structural-typing.preds.html#var-implies"><div class="inner"><span>implies</span></div></a></li><li class="depth-1"><a href="structural-typing.preds.html#var-kvs"><div class="inner"><span>kvs</span></div></a></li><li class="depth-1"><a href="structural-typing.preds.html#var-matches"><div class="inner"><span>matches</span></div></a></li><li class="depth-1"><a href="structural-typing.preds.html#var-member"><div class="inner"><span>member</span></div></a></li><li class="depth-1"><a href="structural-typing.preds.html#var-not-empty.3F"><div class="inner"><span>not-empty?</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">structural-typing.preds</h2><div class="doc"><div class="markdown"><p>A few predefined predicates, but also functions that take expected values and generate predicates.</p></div></div><div class="public anchor" id="var-all-of"><h3>all-of</h3><div class="usage"><code>(all-of &amp; condensed-type-descriptions)</code></div><div class="doc"><div class="markdown"><p>This is used with <a href="structural-typing.preds.html#var-implies">implies</a> to group a collection of <code>condensed-type-descriptions</code> into one. </p>
<pre><code> (all-of (requires :x :y) (includes :Point) {:color string?})
</code></pre></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/preds.clj#L208">view source</a></div></div><div class="public anchor" id="var-at-most-keys"><h3>at-most-keys</h3><div class="usage"><code>(at-most-keys &amp; coll)</code></div><div class="doc"><div class="markdown"><p>Produce a predicate that&rsquo;s false when applied to a map or record with keys other than those given in <code>coll</code>. Note: the value may be <em>missing</em> keys in <code>coll</code>. See <a href="structural-typing.preds.html#var-exactly-keys">exactly-keys</a>.</p>
<pre><code>  user=&gt; (type! :X {:v1 string?
                    :v2 integer?}
                   (at-most-keys :v1 :v2))
  user=&gt; (built-like :X {:v1 &quot;apple&quot;})
  =&gt; {:v1 &quot;apple&quot;}
  user=&gt; (built-like :X {:v1 &quot;apple&quot; :v2 3})
  =&gt; {:v1 &quot;apple&quot;, :v2 3}
  user=&gt; (built-like :X {:v1 &quot;apple&quot; :v2 3, :actual-is-too-big true})
  Value has extra keys: #{:actual-is-too-big}; it is {:v1 &quot;apple&quot;, ...
  =&gt; nil
</code></pre><p>Note: this predicate works only with keys, not paths.</p><p>Note also: all that matters is the presence of keys, not their values.</p></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/preds.clj#L113">view source</a></div></div><div class="public anchor" id="var-exactly"><h3>exactly</h3><div class="usage"><code>(exactly expected)</code></div><div class="doc"><div class="markdown"><p>A predicate that succeeds exactly when its argument is <code>=</code> to <code>expected</code>. Here&rsquo;s an example of defining a versioned type:</p>
<pre><code> (type! :V5 {:version (exactly 5)
             :request ...
             :response ...
             ...}
</code></pre><p>You can also use <code>exactly</code> as a way to check for the presence of a function, rather than applying that function as a checker:</p>
<pre><code> (built-like? even? even?) ; false: the function `even?` is not an even number
 (built-like? (exactly even?) even?) ; true
</code></pre></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/preds.clj#L30">view source</a></div></div><div class="public anchor" id="var-exactly-keys"><h3>exactly-keys</h3><div class="usage"><code>(exactly-keys &amp; coll)</code></div><div class="doc"><div class="markdown"><p>Produce a predicate that&rsquo;s false when applied to a map or record with keys at all different than those given in <code>coll</code>. See <a href="structural-typing.preds.html#var-at-most-keys">at-most-keys</a> for a variant that allows the value to be missing some of the <code>coll</code> keys.</p>
<pre><code> user=&gt; (type! :X {:v1 string?
                   :v2 integer?}
                  (exactly-keys :v1 :v2))
 user=&gt; (built-like :X {:v1 &quot;apple&quot;})
 =&gt; Value has missing keys: #{:v2}; it is {:v1 &quot;apple&quot;}
 nil
 user=&gt; (built-like :X {:v1 &quot;apple&quot; :v2 3})
 {:v1 &quot;apple&quot;, :v2 3}
 user=&gt; (built-like :X {:v1 &quot;apple&quot; :v2 3, :actual-is-too-big true})
 Value has extra keys: #{:actual-is-too-big}; it is {:v1 &quot;apple&quot;, ...
 =&gt; nil
</code></pre><p>Note: this predicate works only with keys, not paths.</p><p>Note also: all that matters is the presence of keys, not their values.</p></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/preds.clj#L143">view source</a></div></div><div class="public anchor" id="var-exactly.3D.3D"><h3>exactly==</h3><div class="usage"><code>(exactly== expected)</code></div><div class="doc"><div class="markdown"><p>This predicate is like <a href="structural-typing.preds.html#var-exactly">exactly</a> except it uses <code>==</code> instead of <code>=</code>. That is, it checks equality irrespective of type. That is, whereas <code>((exactly 1M) 1)</code> is <code>false</code>, <code>((exactly== 1M) 1)</code> is <code>true</code>.</p></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/preds.clj#L51">view source</a></div></div><div class="public anchor" id="var-implies"><h3>implies</h3><div class="usage"><code>(implies if-part then-part if-part then-part ...)</code></div><div class="doc"><div class="markdown"><p>There&rsquo;s enough going on with <code>implies</code> that it has its own  page in the user documentation: <a href="http://bit.ly/1LeLTy9">http://bit.ly/1LeLTy9</a>.</p><p>Both the <code>if</code> and <code>then</code> parts are either a single condensed type description (like <code>(requires :a :b :c)</code>) or a collection of them wrapped in <a href="structural-typing.preds.html#var-all-of">all-of</a>. </p><p>Each <code>if-part</code> is evaluated in turn. When the <code>if-part</code> matches the whole value, then the <code>then-part</code> is applied to check for type errors. Otherwise,the <code>then-part</code> is ignored.</p>
<pre><code> ;; If `:a` is present, `:b` must also be present:
 (type! :X (pred/implies :a :b))  

 ;; If `:a` is absent (or nil), `:b` must be odd.
 (type! :X (pred/implies {:a nil?} {:b [required-path odd?]}))

 ;; A use of `all-of`:
 (type! :X (pred/implies :a (pred/all-of (includes :Point)
                                         (requires :color))))
</code></pre><p>Warning: this &ldquo;predicate&rdquo; cannot be used outside of a structural-typing functions like <code>type!</code>, <code>named</code>, and <code>built-like</code>.</p></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/preds.clj#L231">view source</a></div></div><div class="public anchor" id="var-kvs"><h3>kvs</h3><div class="usage"><code>(kvs maplike)</code></div><div class="doc"><div class="markdown"><p>A variant of <a href="structural-typing.preds.html#var-exactly">exactly</a> that ignores the difference between records and maps.</p><p>In Clojure, compound values are usually equal if their contents are equal. For example:</p>
<pre><code>(= (vector 1 2) (list 1 2)) ;=&gt; true
</code></pre><p>That is not true when comparing records to maps. Therefore, the following will <em>always</em> be false if <code>structure</code> is a record.</p>
<pre><code>(built-like (pred/exactly {:a 1, :b 2}) structure)
</code></pre><p>However, the following will be true, given <code>(defrecord R [a b])</code>:</p>
<pre><code>(built-like (pred/kvs {:a 1, :b 2}) (R. 1 2))
</code></pre><p>Note: <code>kvs</code> is false when given anything other than a map or record.</p></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/preds.clj#L181">view source</a></div></div><div class="public anchor" id="var-matches"><h3>matches</h3><div class="usage"><code>(matches regex)</code></div><div class="doc"><div class="markdown"><p>Produce a predicate that returns true when any part of a string matches <code>regex</code>. (That is, <code>re-find</code> is used instead of <code>re-matches</code>.)</p>
<pre><code>user=&gt; (built-like (pred/matches #&quot;ab+&quot;) &quot;Look at this: abbb. Cool huh?&quot;)
&quot;Look at this: abbb. Cool huh?&quot;
</code></pre></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/preds.clj#L63">view source</a></div></div><div class="public anchor" id="var-member"><h3>member</h3><div class="usage"><code>(member coll)</code></div><div class="doc"><div class="markdown"><p>Produce a predicate that&rsquo;s false when applied to a value not a member of <code>coll</code>. The explainer associated with <code>member</code> prints <code>coll</code>.</p>
<pre><code>  user=&gt; (type! :small-primes {:n (member [2 3 5 7])})
  user=&gt; (built-like :small-primes {:n 2000})
  :n should be a member of `[2 3 5 7]`; it is `2000`
  =&gt; nil
</code></pre></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/preds.clj#L14">view source</a></div></div><div class="public anchor" id="var-not-empty.3F"><h3>not-empty?</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Provides a more pleasant error explanation than <code>(complement empty?)</code> or <code>seq</code>.</p>
<pre><code> user=&gt; (built-like pred/not-empty? [])
 Value should be a non-empty collection; it is `[]`
 =&gt; nil
</code></pre></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/preds.clj#L88">view source</a></div></div></div></body></html>